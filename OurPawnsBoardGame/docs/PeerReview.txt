To start, our providers were very responsive and provided their code right away. This allowed us some time to understand their code given and if we needed to request changes. Originally, provided was a mix of interfaces, classes, and enums which was a bit hard to understand due to the mix. Also, there were some interfaces/classes missing which caused some model files to have import errors. Shortly thereafter, we were able to receive all the classes needed to resolve these import errors. On the other hand, the view files provided were made up of only 3 classes - no interfaces, listeners, etc. We tried to make the adapter without these, but it deemed tough, so the provider happily provided new code with a features list, model listener, panels, views, etc. Overall, it would’ve saved time if the correct code was provided at the start, but since our providers were responsive, it was easy to request the needed code. We appreciate their responsiveness greatly.

Once we started implementing, my partner and I agreed that their view was very well structured and organized. Their views were generally very capable, and allowed us to make the adapters as needed. Unlike us, they made the mouse clicking and key clicking handled by the controller, which made it a little harder to implement into the adapters but it eventually worked. We think that if these items are view/gui related, they should be handled in the view. It was convenient to reuse their code, but of course we had to make adapters for the different components. For instance, we had to adapt our card into their type of card, convert our Cell type into their BoardElement type, adapt their view/listeners, and of course adapt the model. But overall, it wasn’t necessarily difficult, just tedious given the nature and complexity of the project assignment.

Lastly, their code was well documented, well-written, and made it easy to implement what we needed to do. The only bug my partner and I encountered was the mirroring of the cards’ influence on the board. Our code handles the mirroring in the view, but they handle it in their deck parser. Since we are using our model with their view, we had to make some edits in our code to make sure the influence works with their view. Not that one implementation method is better than the other, but this is something we realized and got us thinking about how we may implement things like this better in the future.
